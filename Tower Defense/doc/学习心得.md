# 相机移动

```c#
float mouse = Input.GetAxis("Mouse ScrollWheel");	# 获取鼠标轮滑
transform.Translate(new Vector3(h * speed, mouse * mspeed, v * speed) * Time.deltaTime, Space.World);
# Space.World 相对世界坐标的移动
```

# 敌人生成

```c#
[System.Serializable]	//表面该类可序列化，可直接在Unity上显示操作

// 协成开始
void Start()
{
    StartCoroutine(EnemyGenerate());
}

// 协成生成敌人
IEnumerator EnemyGenerate()
{
    foreach (Wave wave in waves)
    {
        for (int i = 0; i < wave.count; i++)
        {
            GameObject.Instantiate(wave.enemy, MONSTER_START.position, Quaternion.identity);
            enemyCount++;
            if (i != wave.count - 1)
            {
                yield return new WaitForSeconds(wave.rate);
            }
        }
        while (enemyCount > 0)
            yield return 0;
        // 一波敌人结束后才生成另一波敌人
        yield return new WaitForSeconds(waveTime);
    }
}
```

# 创建炮塔

## 切换炮塔事件

![1527150238](E:\unity3d\Tower Defense\doc\1527150238.png)

- 点击Toggle Inspector里面对应的On Value Changed，绑定改变炮塔对应调用的函数

## 获取鼠标点击的游戏对象

```c#
// 返回一个从相机到屏幕点的光线
Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
// debug
Debug.DrawRay(ray.origin, ray.direction * 10, Color.yellow);
RaycastHit hit; // 存放碰撞物体的信息
bool isCollider;

// ray:射线对象
// layerMask:选择那个层进行碰撞检测
// hit:存放碰撞物体的信息
// maxDistance:最远距离
isCollider = Physics.Raycast(ray, out hit, 1000, LayerMask.GetMask("MapCube"));
if (isCollider)
{
    // 得到点击的mapcube
    GameObject mapCube = hit.collider.gameObject;
}
```

## 地图方块控制

- `[HideInInspector]  // 不需要显示在面板 `



# 鼠标移动到cube上颜色变化

![多益云截图1529654848](.\多益云截图1529654848.png)

使用`OnMouseEnter`和`OnMouseExitOnMouseExit` 来进行判断鼠标是否进入cube

建造炮塔后当鼠标移动在炮塔攻击范围内时，发现并不会触发

因为在Edit/Projectsettings/Physics里面勾选了Queries Hit Triggers，首先和炮塔触发了，所以并没有和cube触发，取消勾选。